{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///vue-quagga.js","webpack:///webpack/bootstrap ab17106bd6957dae6703","webpack:///./node_modules/webrtc-adapter/src/js/utils.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/sdp/sdp.js","webpack:///src/Scanner.vue","webpack:///./src/index.js","webpack:///./node_modules/webrtc-adapter/src/js/adapter_core.js","webpack:///./node_modules/webrtc-adapter/src/js/adapter_factory.js","webpack:///./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js","webpack:///./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js","webpack:///./node_modules/webrtc-adapter/src/js/edge/edge_shim.js","webpack:///./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js","webpack:///./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js","webpack:///./node_modules/webrtc-adapter/src/js/edge/getusermedia.js","webpack:///./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js","webpack:///./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js","webpack:///./node_modules/webrtc-adapter/src/js/safari/safari_shim.js","webpack:///./node_modules/webrtc-adapter/src/js/common_shim.js","webpack:///./src/Scanner.vue","webpack:///./src/Scanner.vue?72b9","webpack:///./src/Scanner.vue?3559","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/vue-style-loader/lib/addStylesClient.js","webpack:///./node_modules/vue-style-loader/lib/listToStyles.js","webpack:///./node_modules/vue-loader/lib/component-normalizer.js","webpack:///external \"quagga\"","webpack:///./src/Scanner.vue?0b9f"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_24__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","extractVersion","uastring","expr","pos","match","length","parseInt","wrapPeerConnectionEvent","window","eventNameToWrap","wrapper","RTCPeerConnection","proto","nativeAddEventListener","addEventListener","nativeEventName","cb","apply","arguments","wrappedCallback","e","_eventMap","nativeRemoveEventListener","removeEventListener","unwrappedCb","set","logDisabled_","deprecationWarnings_","disableLog","bool","Error","disableWarnings","log","console","deprecated","oldMethod","newMethod","warn","detectBrowser","navigator","result","browser","version","mozGetUserMedia","userAgent","webkitGetUserMedia","mediaDevices","g","Function","eval","SDPUtils","generateIdentifier","Math","random","toString","substr","localCName","splitLines","blob","trim","split","map","line","splitSections","part","index","getDescription","sections","getMediaSections","shift","matchPrefix","prefix","filter","indexOf","parseCandidate","parts","substring","candidate","foundation","component","protocol","toLowerCase","priority","ip","port","type","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","writeCandidate","sdp","push","toUpperCase","join","parseIceOptions","parseRtpMap","parsed","payloadType","clockRate","channels","numChannels","writeRtpMap","codec","pt","undefined","preferredPayloadType","parseExtmap","id","direction","uri","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","keys","params","forEach","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","attribute","value","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","getIceParameters","concat","password","writeIceParameters","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","mline","rtpmapline","fmtps","writeRtpDescription","kind","caps","maxptime","extension","parseRtpEncodingParameters","secondarySsrc","encodingParameters","hasRed","hasUlpfec","ssrcs","primarySsrc","flows","apt","encParam","codecPayloadType","rtx","JSON","parse","stringify","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","obj","cname","rsize","reducedSize","compound","mux","parseMsid","spec","stream","track","planB","generateSessionId","writeSessionBoilerplate","sessId","sessVer","writeMediaSection","transceiver","iceGatherer","getLocalParameters","dtlsTransport","rtpSender","rtpReceiver","msid","sendEncodingParameters","getDirection","getKind","isRejected","parseMLine","fmt","slice","parseOLine","username","sessionId","sessionVersion","netType","addressType","address","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_quagga__","__WEBPACK_IMPORTED_MODULE_0_quagga___default","props","onDetected","onProcessed","readerType","String","default","readerSize","width","Number","height","data","quaggaState","inputStream","constraints","min","facingMode","aspectRatio","max","locator","patchSize","halfSample","numOfWorkers","frequency","decoder","readers","format","config","locate","mounted","a","init","err","start","_onDetected","_onProcessed","methods","drawingCtx","canvas","ctx","overlay","drawingCanvas","dom","boxes","clearRect","getAttribute","box","ImageDebug","drawPath","x","y","color","lineWidth","codeResult","code","global","install","Vue","__WEBPACK_IMPORTED_MODULE_1__Scanner_vue__","VERSION","Scanner","__WEBPACK_IMPORTED_MODULE_0_webrtc_adapter__","plugin","GlobalVue","use","adapterFactory","utils","dependencies","opts","options","shimChrome","shimFirefox","shimEdge","shimSafari","key","logging","browserDetails","chromeShim","edgeShim","firefoxShim","safariShim","commonShim","adapter","shimPeerConnection","browserShim","shimCreateObjectURL","shimGetUserMedia","shimMediaStream","shimSourceObject","shimOnTrack","shimAddTrackRemoveTrack","shimGetSendersWithDtmf","shimSenderReceiverGetStats","shimRTCIceCandidate","shimMaxMessageSize","shimSendThrowTypeError","shimRemoveStream","shimSenderGetStats","shimReceiverGetStats","shimRTCDataChannel","shimReplaceTrack","shimRTCIceServerUrls","shimCallbacksAPI","shimLocalStreamsAPI","shimRemoteStreamsAPI","shimTrackEventTransceiver","shimCreateOfferLegacy","walkStats","stats","base","resultSet","has","endsWith","filterStats","outbound","streamStatsType","filteredResult","Map","trackStats","trackIdentifier","trackStat","trackId","MediaStream","webkitMediaStream","receiver","_ontrack","f","origSetRemoteDescription","setRemoteDescription","pc","_ontrackpoly","te","getReceivers","find","r","event","Event","streams","dispatchEvent","getTracks","shimSenderWithDtmf","dtmf","_dtmf","createDTMFSender","_pc","getSenders","_senders","origAddTrack","addTrack","sender","origRemoveTrack","removeTrack","idx","splice","origAddStream","addStream","origRemoveStream","removeStream","RTCRtpSender","origGetSenders","senders","RTCRtpReceiver","getStats","then","origGetReceivers","receivers","srcElement","origGetStats","MediaStreamTrack","Promise","reject","DOMException","URL","HTMLMediaElement","_srcObject","src","revokeObjectURL","createObjectURL","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","existingSenders","newSenders","newSender","replaceInternalStreamId","_reverseStreams","internalId","externalStream","internalStream","_streams","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","origGetLocalStreams","nativeStreams","newStream","signalingState","t","oldStream","resolve","method","nativeMethod","args","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","streamid","webkitRTCPeerConnection","pcConfig","pcConstraints","iceTransportPolicy","iceTransports","generateCertificate","OrigPeerConnection","iceServers","newIceServers","server","urls","url","selector","successCallback","errorCallback","fixChromeStats_","response","standardReport","report","standardStats","timestamp","localcandidate","remotecandidate","names","stat","makeMapStats","successCallbackWrapper_","promise","RTCIceCandidate","nativeAddIceCandidate","addIceCandidate","constraintsToChrome_","mandatory","optional","cc","ideal","exact","oldname_","charAt","oc","mix","advanced","shimConstraints_","func","audio","remap","b","video","face","getSupportedFacingModeLies","getSupportedConstraints","matches","enumerateDevices","devices","dev","some","label","deviceId","shimError_","PermissionDeniedError","PermissionDismissedError","InvalidStateError","DevicesNotFoundError","ConstraintNotSatisfiedError","TrackStartError","MediaDeviceFailedDueToShutdown","MediaDeviceKillSwitchOn","TabCaptureError","ScreenCaptureError","DeviceCaptureError","message","constraint","constraintName","getUserMedia_","onSuccess","onError","getUserMedia","getUserMediaPromise_","kinds","getSources","device","groupId","echoCancellation","frameRate","origGetUserMedia","bind","cs","getAudioTracks","getVideoTracks","stop","filterIceServers","shimRTCPeerConnection","RTCIceGatherer","origMSTEnabled","ev","enabled","RTCDtmfSender","RTCDTMFSender","RTCPeerConnectionShim","replaceTrack","setTrack","edgeVersion","hasTurn","isString","fixStatsType","inboundrtp","outboundrtp","candidatepair","dtlsRole","_initialTrackId","getCommonCapabilities","localCapabilities","remoteCapabilities","commonCapabilities","findCodecByPayloadType","rtxCapabilityMatches","lRtx","rRtx","lCodecs","rCodecs","lCodec","rCodec","lHeaderExtension","rHeaderExtension","isActionAllowedInSignalingState","action","offer","answer","maybeAddCandidate","iceTransport","alreadyAdded","getRemoteCandidates","remoteCandidate","addRemoteCandidate","makeError","NotSupportedError","InvalidAccessError","TypeError","OperationError","addTrackToStreamAndFireEvent","MediaStreamTrackEvent","removeTrackFromStreamAndFireEvent","fireAddTrack","trackEvent","setTimeout","_dispatchEvent","_eventTarget","document","createDocumentFragment","canTrickleIceCandidates","needNegotiation","localStreams","remoteStreams","localDescription","remoteDescription","iceConnectionState","connectionState","iceGatheringState","usingBundle","bundlePolicy","rtcpMuxPolicy","_iceGatherers","iceCandidatePoolSize","gatherPolicy","_config","transceivers","_sdpSessionId","_sdpSessionVersion","_dtlsRole","_isClosed","onicecandidate","onaddstream","ontrack","onremovestream","onsignalingstatechange","oniceconnectionstatechange","onconnectionstatechange","onicegatheringstatechange","onnegotiationneeded","ondatachannel","_emitGatheringStateChange","getConfiguration","getRemoteStreams","_createTransceiver","doNotAdd","hasBundleTransport","recvEncodingParameters","associatedRemoteMediaStreams","wantReceive","transports","_createIceAndDtlsTransports","_maybeFireNegotiationNeeded","clonedStream","clone","clonedTrack","_createIceGatherer","sdpMLineIndex","writable","bufferedCandidateEvents","bufferCandidates","end","state","_gather","onlocalcandidate","evt","sdpMid","cand","serializedCandidate","assign","toJSON","complete","every","RTCIceTransport","onicestatechange","_updateIceConnectionState","_updateConnectionState","RTCDtlsTransport","ondtlsstatechange","onerror","_disposeIceAndDtlsTransports","_transceive","send","recv","encodings","receive","isIceLite","rejected","remoteIceParameters","remoteDtlsParameters","_updateSignalingState","receiverList","iceOptions","remoteMsid","isComplete","cands","setTransport","setRemoteCandidates","getCapabilities","isNewTrack","nativeTrack","sid","item","close","newState","states","new","closed","checking","connected","completed","disconnected","failed","connecting","createOffer","numAudioTracks","numVideoTracks","offerOptions","offerToReceiveAudio","offerToReceiveVideo","remoteCodec","hdrExt","rHdrExt","getLocalCandidates","createAnswer","mediaSectionsInOffer","localTrack","candidateString","senderOrReceiver","promises","all","allStats","results","ortcObjectName","nativeGetstats","nativeStats","mapStats","error","catch","RTCTrackEvent","mozSrcObject","mozRTCPeerConnection","newServer","credential","mozRTCSessionDescription","mozRTCIceCandidate","modernStatsTypes","nativeGetStats","onSucc","onErr","DataChannel","RTCDataChannel","InternalError","SecurityError","The operation is insecure.","constraintsToFF37_","orgEnumerateDevices","nativeGetUserMedia","getSettings","nativeGetSettings","applyConstraints","nativeApplyConstraints","_localStreams","getStreamById","_remoteStreams","_addTrack","tracks","_onaddstream","_onaddstreampoly","failureCallback","withCallback","errcb","RTCTransceiver","origCreateOffer","audioTransceiver","getTransceivers","setDirection","addTransceiver","videoTransceiver","NativeRTCIceCandidate","nativeCandidate","parsedCandidate","augmentedCandidate","nativeCreateObjectURL","nativeRevokeObjectURL","newId","delete","dsc","srcObject","nativeSetAttribute","setAttribute","RTCSctpTransport","_sctp","sctpInDescription","mLine","getRemoteFirefoxVersion","getCanSendMaxMessageSize","remoteIsFirefox","canSendMaxMessageSize","getMaxMessageSize","maxMessageSize","isFirefox","canSendMMS","remoteMMS","POSITIVE_INFINITY","sctp","wrapDcSend","dc","origDataChannelSend","size","byteLength","readyState","origCreateDataChannel","createDataChannel","dataChannel","channel","target","injectStyle","ssrContext","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Scanner_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_047f45f1_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Scanner_vue__","normalizeComponent","__vue_styles__","Component","content","locals","cssWithMappingToString","useSourceMap","cssMapping","btoa","sourceMapping","toComment","sources","source","sourceRoot","sourceMap","unescape","encodeURIComponent","list","mediaQuery","alreadyImportedModules","addStylesToDom","styles","domStyle","stylesInDom","refs","addStyle","createStyleElement","styleElement","createElement","head","appendChild","update","remove","querySelector","ssrIdKey","isProduction","noop","parentNode","removeChild","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","css","media","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","insertBefore","ssrId","firstChild","hasDocument","DEBUG","listToStyles","getElementsByTagName","test","parentId","_isProduction","_options","newList","mayRemove","textStore","replacement","Boolean","newStyles","rawScriptExports","compiledTemplate","functionalTemplate","injectStyles","scopeId","moduleIdentifier","esModule","scriptExports","render","staticRenderFns","_compiled","functional","_scopeId","hook","context","$vnode","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","existing","beforeCreate","_injectStyles","h","_vm","_h","$createElement","_self","_c","_m","staticClass","attrs","_v","esExports"],"mappings":"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","file":"vue-quagga.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"quagga\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Scanner\", [\"quagga\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Scanner\"] = factory(require(\"quagga\"));\n\telse\n\t\troot[\"Scanner\"] = factory(root[\"quagga\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_24__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"quagga\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Scanner\", [\"quagga\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Scanner\"] = factory(require(\"quagga\"));\n\telse\n\t\troot[\"Scanner\"] = factory(root[\"quagga\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_24__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object.\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  var nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    var wrappedCallback = function(e) {\n      cb(wrapper(e));\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  var nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    var unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get: function() {\n      return this['_on' + eventNameToWrap];\n    },\n    set: function(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\n// Utility methods.\nmodule.exports = {\n  extractVersion: extractVersion,\n  wrapPeerConnectionEvent: wrapPeerConnectionEvent,\n  disableLog: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return (bool) ? 'adapter.js logging disabled' :\n        'adapter.js logging enabled';\n  },\n\n  /**\n   * Disable or enable deprecation warnings\n   * @param {!boolean} bool set to true to disable warnings.\n   */\n  disableWarnings: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n  },\n\n  log: function() {\n    if (typeof window === 'object') {\n      if (logDisabled_) {\n        return;\n      }\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  },\n\n  /**\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\n   */\n  deprecated: function(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n      return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n        ' instead.');\n  },\n\n  /**\n   * Browser detector.\n   *\n   * @return {object} result containing browser and version\n   *     properties.\n   */\n  detectBrowser: function(window) {\n    var navigator = window && window.navigator;\n\n    // Returned result object.\n    var result = {};\n    result.browser = null;\n    result.version = null;\n\n    // Fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a browser.';\n      return result;\n    }\n\n    if (navigator.mozGetUserMedia) { // Firefox.\n      result.browser = 'firefox';\n      result.version = extractVersion(navigator.userAgent,\n          /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome, Chromium, Webview, Opera.\n      // Version matches Chrome/WebRTC version.\n      result.browser = 'chrome';\n      result.version = extractVersion(navigator.userAgent,\n          /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (navigator.mediaDevices &&\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n      result.browser = 'edge';\n      result.version = extractVersion(navigator.userAgent,\n          /Edge\\/(\\d+).(\\d+)$/, 2);\n    } else if (window.RTCPeerConnection &&\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n      result.browser = 'safari';\n      result.version = extractVersion(navigator.userAgent,\n          /AppleWebKit\\/(\\d+)\\./, 1);\n    } else { // Default fallthrough: not supported.\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    return result;\n  }\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n /* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n}\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n}\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.substr(17).split(' ');\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: secondarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  var cname;\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n}\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_quagga__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_quagga___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_quagga__);\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  name: \"scanner\",\n  props: {\n    onDetected: {\n      type: Function\n    },\n    onProcessed: {\n      type: Function\n    },\n    readerType: {\n      type: String,\n      default: 'code_128_reader'\n    },\n    readerSize: {\n      width: {\n        type: Number,\n        default: 640\n      },\n      height: {\n        type: Number,\n        default: 480\n      }\n    }\n  },\n  data: function data() {\n    return {\n      quaggaState: {\n        inputStream: {\n          type: 'LiveStream',\n          constraints: {\n            width: { min: this.readerSize.width },\n            height: { min: this.readerSize.height },\n            facingMode: 'environment',\n            aspectRatio: { min: 1, max: 2 }\n          }\n        },\n        locator: {\n          patchSize: 'medium',\n          halfSample: true\n        },\n        numOfWorkers: 2,\n        frequency: 10,\n        decoder: {\n          readers: [{\n            format: this.readerType,\n            config: {}\n          }]\n        },\n        locate: true\n      }\n    };\n  },\n  mounted: function mounted() {\n    __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.init(this.quaggaState, function (err) {\n      if (err) {\n        return console.log(err);\n      }\n      __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.start();\n    });\n    __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.onDetected(this.onDetected ? this.onDetected : this._onDetected);\n    __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.onProcessed(this.onProcessed ? this.onProcessed : this._onProcessed);\n  },\n  methods: {\n    _onProcessed: function _onProcessed(result) {\n      var drawingCtx = __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.canvas.ctx.overlay,\n          drawingCanvas = __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.canvas.dom.overlay;\n\n      if (result) {\n        if (result.boxes) {\n          drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute(\"width\")), parseInt(drawingCanvas.getAttribute(\"height\")));\n          result.boxes.filter(function (box) {\n            return box !== result.box;\n          }).forEach(function (box) {\n            __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.ImageDebug.drawPath(box, { x: 0, y: 1 }, drawingCtx, { color: \"green\", lineWidth: 2 });\n          });\n        }\n        if (result.box) {\n          __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.ImageDebug.drawPath(result.box, { x: 0, y: 1 }, drawingCtx, { color: \"#00F\", lineWidth: 2 });\n        }\n\n        if (result.codeResult && result.codeResult.code) {\n          __WEBPACK_IMPORTED_MODULE_0_quagga___default.a.ImageDebug.drawPath(result.line, { x: 'x', y: 'y' }, drawingCtx, { color: 'red', lineWidth: 3 });\n        }\n      }\n    },\n    _onDetected: function _onDetected(result) {\n      console.log('detected: ', result);\n    }\n  }\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scanner\", function() { return Scanner; });\n/* harmony export (immutable) */ __webpack_exports__[\"install\"] = install;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webrtc_adapter__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webrtc_adapter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_webrtc_adapter__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Scanner_vue__ = __webpack_require__(17);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaggaScanner\", function() { return __WEBPACK_IMPORTED_MODULE_1__Scanner_vue__[\"a\"]; });\n\n\n\nvar VERSION = '1.0.0';\n\nvar Scanner = __WEBPACK_IMPORTED_MODULE_1__Scanner_vue__[\"a\" /* default */];\n// Install the components\nfunction install(Vue) {\n  Vue.component('quagga-scanner', __WEBPACK_IMPORTED_MODULE_1__Scanner_vue__[\"a\" /* default */]);\n}\n\n// Expose the components\n\n\n/* -- Plugin definition & Auto-install -- */\n/* You shouldn't have to modify the code below */\n\n// Plugin\nvar plugin = {\n  /* eslint-disable no-undef */\n  version: VERSION,\n  install: install\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (plugin);\n\n// Auto-install\nvar GlobalVue = null;\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\nvar adapterFactory = __webpack_require__(6);\nmodule.exports = adapterFactory({window: global.window});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\nvar utils = __webpack_require__(0);\n// Shimming starts here.\nmodule.exports = function(dependencies, opts) {\n  var window = dependencies && dependencies.window;\n\n  var options = {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true,\n  };\n\n  for (var key in opts) {\n    if (hasOwnProperty.call(opts, key)) {\n      options[key] = opts[key];\n    }\n  }\n\n  // Utils.\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  // Uncomment the line below if you want logging to occur, including logging\n  // for the switch statement below. Can also be turned on in the browser via\n  // adapter.disableLog(false), but then logging from the switch statement below\n  // will not appear.\n  // require('./utils').disableLog(false);\n\n  // Browser shims.\n  var chromeShim = __webpack_require__(7) || null;\n  var edgeShim = __webpack_require__(9) || null;\n  var firefoxShim = __webpack_require__(13) || null;\n  var safariShim = __webpack_require__(15) || null;\n  var commonShim = __webpack_require__(16) || null;\n\n  // Export to the adapter global object visible in the browser.\n  var adapter = {\n    browserDetails: browserDetails,\n    commonShim: commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      chromeShim.shimSourceObject(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n      chromeShim.shimSenderReceiverGetStats(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n      commonShim.shimCreateObjectURL(window);\n\n      firefoxShim.shimGetUserMedia(window);\n      firefoxShim.shimSourceObject(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      firefoxShim.shimRemoveStream(window);\n      firefoxShim.shimSenderGetStats(window);\n      firefoxShim.shimReceiverGetStats(window);\n      firefoxShim.shimRTCDataChannel(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      edgeShim.shimGetUserMedia(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n      commonShim.shimCreateObjectURL(window);\n\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimTrackEventTransceiver(window);\n      safariShim.shimGetUserMedia(window);\n      safariShim.shimCreateOfferLegacy(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(0);\nvar logging = utils.log;\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(function(name) {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(function(id) {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  var filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  var trackStats = [];\n  result.forEach(function(value) {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(function(trackStat) {\n    result.forEach(function(stats) {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(8),\n  shimMediaStream: function(window) {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n          }\n          this.addEventListener('track', this._ontrack = f);\n        }\n      });\n      var origSetRemoteDescription =\n          window.RTCPeerConnection.prototype.setRemoteDescription;\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n        var pc = this;\n        if (!pc._ontrackpoly) {\n          pc._ontrackpoly = function(e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function(te) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === te.track.id;\n                });\n              } else {\n                receiver = {track: te.track};\n              }\n\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function(track) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === track.id;\n                });\n              } else {\n                receiver = {track: track};\n              }\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n          };\n          pc.addEventListener('addstream', pc._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n    } else if (!('RTCRtpTransceiver' in window)) {\n      utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n        if (!e.transceiver) {\n          e.transceiver = {receiver: e.receiver};\n        }\n        return e;\n      });\n    }\n  },\n\n  shimGetSendersWithDtmf: function(window) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\n      var shimSenderWithDtmf = function(pc, track) {\n        return {\n          track: track,\n          get dtmf() {\n            if (this._dtmf === undefined) {\n              if (track.kind === 'audio') {\n                this._dtmf = pc.createDTMFSender(track);\n              } else {\n                this._dtmf = null;\n              }\n            }\n            return this._dtmf;\n          },\n          _pc: pc\n        };\n      };\n\n      // augment addTrack when getSenders is not available.\n      if (!window.RTCPeerConnection.prototype.getSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          this._senders = this._senders || [];\n          return this._senders.slice(); // return a copy of the internal state.\n        };\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n          var pc = this;\n          var sender = origAddTrack.apply(pc, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(pc, track);\n            pc._senders.push(sender);\n          }\n          return sender;\n        };\n\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n          var pc = this;\n          origRemoveTrack.apply(pc, arguments);\n          var idx = pc._senders.indexOf(sender);\n          if (idx !== -1) {\n            pc._senders.splice(idx, 1);\n          }\n        };\n      }\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origAddStream.apply(pc, [stream]);\n        stream.getTracks().forEach(function(track) {\n          pc._senders.push(shimSenderWithDtmf(pc, track));\n        });\n      };\n\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origRemoveStream.apply(pc, [stream]);\n\n        stream.getTracks().forEach(function(track) {\n          var sender = pc._senders.find(function(s) {\n            return s.track === track;\n          });\n          if (sender) {\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\n          }\n        });\n      };\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\n               'getSenders' in window.RTCPeerConnection.prototype &&\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\n               window.RTCRtpSender &&\n               !('dtmf' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = this._pc.createDTMFSender(this.track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n  },\n\n  shimSenderReceiverGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender && window.RTCRtpReceiver)) {\n      return;\n    }\n\n    // shim sender stats.\n    if (!('getStats' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      if (origGetSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          var pc = this;\n          var senders = origGetSenders.apply(pc, []);\n          senders.forEach(function(sender) {\n            sender._pc = pc;\n          });\n          return senders;\n        };\n      }\n\n      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      if (origAddTrack) {\n        window.RTCPeerConnection.prototype.addTrack = function() {\n          var sender = origAddTrack.apply(this, arguments);\n          sender._pc = this;\n          return sender;\n        };\n      }\n      window.RTCRtpSender.prototype.getStats = function() {\n        var sender = this;\n        return this._pc.getStats().then(function(result) {\n          /* Note: this will include stats of all senders that\n           *   send a track with the same id as sender.track as\n           *   it is not possible to identify the RTCRtpSender.\n           */\n          return filterStats(result, sender.track, true);\n        });\n      };\n    }\n\n    // shim receiver stats.\n    if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n      if (origGetReceivers) {\n        window.RTCPeerConnection.prototype.getReceivers = function() {\n          var pc = this;\n          var receivers = origGetReceivers.apply(pc, []);\n          receivers.forEach(function(receiver) {\n            receiver._pc = pc;\n          });\n          return receivers;\n        };\n      }\n      utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n        e.receiver._pc = e.srcElement;\n        return e;\n      });\n      window.RTCRtpReceiver.prototype.getStats = function() {\n        var receiver = this;\n        return this._pc.getStats().then(function(result) {\n          return filterStats(result, receiver.track, false);\n        });\n      };\n    }\n\n    if (!('getStats' in window.RTCRtpSender.prototype &&\n        'getStats' in window.RTCRtpReceiver.prototype)) {\n      return;\n    }\n\n    // shim RTCPeerConnection.getStats(track).\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function() {\n      var pc = this;\n      if (arguments.length > 0 &&\n          arguments[0] instanceof window.MediaStreamTrack) {\n        var track = arguments[0];\n        var sender;\n        var receiver;\n        var err;\n        pc.getSenders().forEach(function(s) {\n          if (s.track === track) {\n            if (sender) {\n              err = true;\n            } else {\n              sender = s;\n            }\n          }\n        });\n        pc.getReceivers().forEach(function(r) {\n          if (r.track === track) {\n            if (receiver) {\n              err = true;\n            } else {\n              receiver = r;\n            }\n          }\n          return r.track === track;\n        });\n        if (err || (sender && receiver)) {\n          return Promise.reject(new DOMException(\n            'There are more than one sender or receiver for the track.',\n            'InvalidAccessError'));\n        } else if (sender) {\n          return sender.getStats();\n        } else if (receiver) {\n          return receiver.getStats();\n        }\n        return Promise.reject(new DOMException(\n          'There is no sender or receiver for the track.',\n          'InvalidAccessError'));\n      }\n      return origGetStats.apply(pc, arguments);\n    };\n  },\n\n  shimSourceObject: function(window) {\n    var URL = window && window.URL;\n\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this._srcObject;\n          },\n          set: function(stream) {\n            var self = this;\n            // Use _srcObject as a private property for this shim\n            this._srcObject = stream;\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return undefined;\n            }\n            this.src = URL.createObjectURL(stream);\n            // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n            stream.addEventListener('addtrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n\n  shimAddTrackRemoveTrackWithNative: function(window) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {\n        return pc._shimmedLocalStreams[streamId][0];\n      });\n    };\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      var sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      var existingSenders = pc.getSenders();\n      origAddStream.apply(this, arguments);\n      var newSenders = pc.getSenders().filter(function(newSender) {\n        return existingSenders.indexOf(newSender) === -1;\n      });\n      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {\n          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            pc._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (pc._shimmedLocalStreams[streamId].length === 1) {\n            delete pc._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n  },\n\n  shimAddTrackRemoveTrack: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n    // shim addTrack and removeTrack.\n    if (window.RTCPeerConnection.prototype.addTrack &&\n        browserDetails.version >= 65) {\n      return this.shimAddTrackRemoveTrackWithNative(window);\n    }\n\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\n        .getLocalStreams;\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      var nativeStreams = origGetLocalStreams.apply(this);\n      pc._reverseStreams = pc._reverseStreams || {};\n      return nativeStreams.map(function(stream) {\n        return pc._reverseStreams[stream.id];\n      });\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      // Add identity mapping for consistency with addTrack.\n      // Unless this is being used with a stream from addTrack.\n      if (!pc._reverseStreams[stream.id]) {\n        var newStream = new window.MediaStream(stream.getTracks());\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        stream = newStream;\n      }\n      origAddStream.apply(pc, [stream]);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\n          pc._streams[stream.id].id : stream.id)];\n      delete pc._streams[stream.id];\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      var streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(function(t) {\n            return t === track;\n          })) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      var alreadyExists = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n      var oldStream = pc._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(function() {\n          pc.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        var newStream = new window.MediaStream([track]);\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        pc.addStream(newStream);\n      }\n      return pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n    };\n\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n            externalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    function replaceExternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n            internalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    ['createOffer', 'createAnswer'].forEach(function(method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function() {\n        var pc = this;\n        var args = arguments;\n        var isLegacyCall = arguments.length &&\n            typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(pc, [\n            function(description) {\n              var desc = replaceInternalStreamId(pc, description);\n              args[0].apply(null, [desc]);\n            },\n            function(err) {\n              if (args[1]) {\n                args[1].apply(null, err);\n              }\n            }, arguments[2]\n          ]);\n        }\n        return nativeMethod.apply(pc, arguments)\n        .then(function(description) {\n          return replaceInternalStreamId(pc, description);\n        });\n      };\n    });\n\n    var origSetLocalDescription =\n        window.RTCPeerConnection.prototype.setLocalDescription;\n    window.RTCPeerConnection.prototype.setLocalDescription = function() {\n      var pc = this;\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(pc, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\n      return origSetLocalDescription.apply(pc, arguments);\n    };\n\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n    var origLocalDescription = Object.getOwnPropertyDescriptor(\n        window.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window.RTCPeerConnection.prototype,\n        'localDescription', {\n          get: function() {\n            var pc = this;\n            var description = origLocalDescription.get.apply(this);\n            if (description.type === '') {\n              return description;\n            }\n            return replaceInternalStreamId(pc, description);\n          }\n        });\n\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      var isLocal = sender._pc === pc;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      pc._streams = pc._streams || {};\n      var stream;\n      Object.keys(pc._streams).forEach(function(streamid) {\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\n          return sender.track === track;\n        });\n        if (hasTrack) {\n          stream = pc._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          pc.removeStream(pc._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.webkitRTCPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      if (window.webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n    } else {\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n      var OrigPeerConnection = window.RTCPeerConnection;\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n          var newIceServers = [];\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\n            var server = pcConfig.iceServers[i];\n            if (!server.hasOwnProperty('urls') &&\n                server.hasOwnProperty('url')) {\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n              server = JSON.parse(JSON.stringify(server));\n              server.urls = server.url;\n              newIceServers.push(server);\n            } else {\n              newIceServers.push(pcConfig.iceServers[i]);\n            }\n          }\n          pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(selector,\n        successCallback, errorCallback) {\n      var pc = this;\n      var args = arguments;\n\n      // If selector is a function then we are in the old style stats so just\n      // pass back the original getStats format to avoid breaking old users.\n      if (arguments.length > 0 && typeof selector === 'function') {\n        return origGetStats.apply(this, arguments);\n      }\n\n      // When spec-style getStats is supported, return those when called with\n      // either no arguments or the selector argument is null.\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\n          typeof arguments[0] !== 'function')) {\n        return origGetStats.apply(this, []);\n      }\n\n      var fixChromeStats_ = function(response) {\n        var standardReport = {};\n        var reports = response.result();\n        reports.forEach(function(report) {\n          var standardStats = {\n            id: report.id,\n            timestamp: report.timestamp,\n            type: {\n              localcandidate: 'local-candidate',\n              remotecandidate: 'remote-candidate'\n            }[report.type] || report.type\n          };\n          report.names().forEach(function(name) {\n            standardStats[name] = report.stat(name);\n          });\n          standardReport[standardStats.id] = standardStats;\n        });\n\n        return standardReport;\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function(stats) {\n        return new Map(Object.keys(stats).map(function(key) {\n          return [key, stats[key]];\n        }));\n      };\n\n      if (arguments.length >= 2) {\n        var successCallbackWrapper_ = function(response) {\n          args[1](makeMapStats(fixChromeStats_(response)));\n        };\n\n        return origGetStats.apply(this, [successCallbackWrapper_,\n          arguments[0]]);\n      }\n\n      // promise-support\n      return new Promise(function(resolve, reject) {\n        origGetStats.apply(pc, [\n          function(response) {\n            resolve(makeMapStats(fixChromeStats_(response)));\n          }, reject]);\n      }).then(successCallback, errorCallback);\n    };\n\n    // add promise support -- natively available in Chrome 51\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\n            window.RTCPeerConnection.prototype[method] = function() {\n              var args = arguments;\n              var pc = this;\n              var promise = new Promise(function(resolve, reject) {\n                nativeMethod.apply(pc, [args[0], resolve, reject]);\n              });\n              if (args.length < 2) {\n                return promise;\n              }\n              return promise.then(function() {\n                args[1].apply(null, []);\n              },\n              function(err) {\n                if (args.length >= 3) {\n                  args[2].apply(null, [err]);\n                }\n              });\n            };\n          });\n    }\n\n    // promise support for createOffer and createAnswer. Available (without\n    // bugs) since M52: crbug/619289\n    if (browserDetails.version < 52) {\n      ['createOffer', 'createAnswer'].forEach(function(method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          var pc = this;\n          if (arguments.length < 1 || (arguments.length === 1 &&\n              typeof arguments[0] === 'object')) {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function(resolve, reject) {\n              nativeMethod.apply(pc, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n    }\n\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(0);\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n\n  var constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function(key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function(mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      var remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      var getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(function(devices) {\n            devices = devices.filter(function(d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function(d) {\n              return matches.some(function(match) {\n                return d.label.toLowerCase().indexOf(match) !== -1;\n              });\n            });\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraintName,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function(c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_;\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  };\n\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {\n      getUserMedia: getUserMediaPromise_,\n      enumerateDevices: function() {\n        return new Promise(function(resolve) {\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\n          return window.MediaStreamTrack.getSources(function(devices) {\n            resolve(devices.map(function(device) {\n              return {label: device.label,\n                kind: kinds[device.kind],\n                deviceId: device.id,\n                groupId: ''};\n            }));\n          });\n        });\n      },\n      getSupportedConstraints: function() {\n        return {\n          deviceId: true, echoCancellation: true, facingMode: true,\n          frameRate: true, height: true, width: true\n        };\n      }\n    };\n  }\n\n  // A shim for getUserMedia method on the mediaDevices object.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (!navigator.mediaDevices.getUserMedia) {\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return getUserMediaPromise_(constraints);\n    };\n  } else {\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, function(c) {\n        return origGetUserMedia(c).then(function(stream) {\n          if (c.audio && !stream.getAudioTracks().length ||\n              c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function(track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function(e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n\n  // Dummy devicechange event methods.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n    navigator.mediaDevices.addEventListener = function() {\n      logging('Dummy mediaDevices.addEventListener called.');\n    };\n  }\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n    navigator.mediaDevices.removeEventListener = function() {\n      logging('Dummy mediaDevices.removeEventListener called.');\n    };\n  }\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(0);\nvar filterIceServers = __webpack_require__(10);\nvar shimRTCPeerConnection = __webpack_require__(11);\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(12),\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (window.RTCIceGatherer) {\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function(args) {\n          return args;\n        };\n      }\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function(args) {\n          return args;\n        };\n      }\n      // this adds an additional event listener to MediaStrackTrack that signals\n      // when a tracks enabled property was changed. Workaround for a bug in\n      // addStream, see below. No longer required in 15025+\n      if (browserDetails.version < 15025) {\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\n            window.MediaStreamTrack.prototype, 'enabled');\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n          set: function(value) {\n            origMSTEnabled.set.call(this, value);\n            var ev = new Event('enabled');\n            ev.enabled = value;\n            this.dispatchEvent(ev);\n          }\n        });\n      }\n    }\n\n    // ORTC defines the DTMF sender a bit different.\n    // https://github.com/w3c/ortc/issues/714\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = new window.RTCDtmfSender(this);\n            } else if (this.track.kind === 'video') {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n    // Edge currently only implements the RTCDtmfSender, not the\n    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n    if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n      window.RTCDTMFSender = window.RTCDtmfSender;\n    }\n\n    var RTCPeerConnectionShim = shimRTCPeerConnection(window,\n        browserDetails.version);\n    window.RTCPeerConnection = function(config) {\n      if (config && config.iceServers) {\n        config.iceServers = filterIceServers(config.iceServers);\n      }\n      return new RTCPeerConnectionShim(config);\n    };\n    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n  },\n  shimReplaceTrack: function(window) {\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n    if (window.RTCRtpSender &&\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\n      window.RTCRtpSender.prototype.replaceTrack =\n          window.RTCRtpSender.prototype.setTrack;\n    }\n  }\n};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(0);\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nmodule.exports = function(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(2);\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all field are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this.localDescription = null;\n    this.remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // dpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc.localDescription.sdp =\n          SDPUtils.getDescription(pc.localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if ((kind === 'application' && protocol === 'DTLS/SCTP') || rejected) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc.remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc.remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(function(e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(14),\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\n            e.stream.getTracks().forEach(function(track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = {track: track};\n              event.transceiver = {receiver: event.receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n    if (typeof window === 'object' && window.RTCTrackEvent &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        !('transceiver' in window.RTCTrackEvent.prototype)) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this.mozSrcObject;\n          },\n          set: function(stream) {\n            this.mozSrcObject = stream;\n          }\n        });\n      }\n    }\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n        window.mozRTCPeerConnection)) {\n      return; // probably media.peerconnection.enabled=false in about:config\n    }\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (browserDetails.version < 38) {\n          // .urls is not supported in FF < 38.\n          // create RTCIceServers with a single url.\n          if (pcConfig && pcConfig.iceServers) {\n            var newIceServers = [];\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\n              var server = pcConfig.iceServers[i];\n              if (server.hasOwnProperty('urls')) {\n                for (var j = 0; j < server.urls.length; j++) {\n                  var newServer = {\n                    url: server.urls[j]\n                  };\n                  if (server.urls[j].indexOf('turn') === 0) {\n                    newServer.username = server.username;\n                    newServer.credential = server.credential;\n                  }\n                  newIceServers.push(newServer);\n                }\n              } else {\n                newIceServers.push(pcConfig.iceServers[i]);\n              }\n            }\n            pcConfig.iceServers = newIceServers;\n          }\n        }\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.mozRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (window.mozRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.mozRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\n    }\n\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function(stats) {\n      var map = new Map();\n      Object.keys(stats).forEach(function(key) {\n        map.set(key, stats[key]);\n        map[key] = stats[key];\n      });\n      return map;\n    };\n\n    var modernStatsTypes = {\n      inboundrtp: 'inbound-rtp',\n      outboundrtp: 'outbound-rtp',\n      candidatepair: 'candidate-pair',\n      localcandidate: 'local-candidate',\n      remotecandidate: 'remote-candidate'\n    };\n\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(\n      selector,\n      onSucc,\n      onErr\n    ) {\n      return nativeGetStats.apply(this, [selector || null])\n        .then(function(stats) {\n          if (browserDetails.version < 48) {\n            stats = makeMapStats(stats);\n          }\n          if (browserDetails.version < 53 && !onSucc) {\n            // Shim only promise getStats with spec-hyphens in type names\n            // Leave callback version alone; misc old uses of forEach before Map\n            try {\n              stats.forEach(function(stat) {\n                stat.type = modernStatsTypes[stat.type] || stat.type;\n              });\n            } catch (e) {\n              if (e.name !== 'TypeError') {\n                throw e;\n              }\n              // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n              stats.forEach(function(stat, i) {\n                stats.set(i, Object.assign({}, stat, {\n                  type: modernStatsTypes[stat.type] || stat.type\n                }));\n              });\n            }\n          }\n          return stats;\n        })\n        .then(onSucc, onErr);\n    };\n  },\n\n  shimSenderGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n      return;\n    }\n    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n    }\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function() {\n        var sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function() {\n      return this.track ? this._pc.getStats(this.track) :\n          Promise.resolve(new Map());\n    };\n  },\n\n  shimReceiverGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n      return;\n    }\n    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function() {\n        var pc = this;\n        var receivers = origGetReceivers.apply(pc, []);\n        receivers.forEach(function(receiver) {\n          receiver._pc = pc;\n        });\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function() {\n      return this._pc.getStats(this.track);\n    };\n  },\n\n  shimRemoveStream: function(window) {\n    if (!window.RTCPeerConnection ||\n        'removeStream' in window.RTCPeerConnection.prototype) {\n      return;\n    }\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(function(sender) {\n        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {\n          pc.removeTrack(sender);\n        }\n      });\n    };\n  },\n\n  shimRTCDataChannel: function(window) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window.DataChannel && !window.RTCDataChannel) {\n      window.RTCDataChannel = window.DataChannel;\n    }\n  },\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(0);\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        InternalError: 'NotReadableError',\n        NotSupportedError: 'TypeError',\n        PermissionDeniedError: 'NotAllowedError',\n        SecurityError: 'NotAllowedError'\n      }[e.name] || e.name,\n      message: {\n        'The operation is insecure.': 'The request is not allowed by the ' +\n        'user agent or the platform in the current context.'\n      }[e.message] || e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  // getUserMedia constraints shim.\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    var constraintsToFF37_ = function(c) {\n      if (typeof c !== 'object' || c.require) {\n        return c;\n      }\n      var require = [];\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = c[key] = (typeof c[key] === 'object') ?\n            c[key] : {ideal: c[key]};\n        if (r.min !== undefined ||\n            r.max !== undefined || r.exact !== undefined) {\n          require.push(key);\n        }\n        if (r.exact !== undefined) {\n          if (typeof r.exact === 'number') {\n            r. min = r.max = r.exact;\n          } else {\n            c[key] = r.exact;\n          }\n          delete r.exact;\n        }\n        if (r.ideal !== undefined) {\n          c.advanced = c.advanced || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[key] = {min: r.ideal, max: r.ideal};\n          } else {\n            oc[key] = r.ideal;\n          }\n          c.advanced.push(oc);\n          delete r.ideal;\n          if (!Object.keys(r).length) {\n            delete c[key];\n          }\n        }\n      });\n      if (require.length) {\n        c.require = require;\n      }\n      return c;\n    };\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (browserDetails.version < 38) {\n      logging('spec: ' + JSON.stringify(constraints));\n      if (constraints.audio) {\n        constraints.audio = constraintsToFF37_(constraints.audio);\n      }\n      if (constraints.video) {\n        constraints.video = constraintsToFF37_(constraints.video);\n      }\n      logging('ff37: ' + JSON.stringify(constraints));\n    }\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n      onError(shimError_(e));\n    });\n  };\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      getUserMedia_(constraints, resolve, reject);\n    });\n  };\n\n  // Shim for mediaDevices on older versions.\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n      addEventListener: function() { },\n      removeEventListener: function() { }\n    };\n  }\n  navigator.mediaDevices.enumerateDevices =\n      navigator.mediaDevices.enumerateDevices || function() {\n        return new Promise(function(resolve) {\n          var infos = [\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n          ];\n          resolve(infos);\n        });\n      };\n\n  if (browserDetails.version < 41) {\n    // Work around http://bugzil.la/1169665\n    var orgEnumerateDevices =\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n    navigator.mediaDevices.enumerateDevices = function() {\n      return orgEnumerateDevices().then(undefined, function(e) {\n        if (e.name === 'NotFoundError') {\n          return [];\n        }\n        throw e;\n      });\n    };\n  }\n  if (browserDetails.version < 49) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      return origGetUserMedia(c).then(function(stream) {\n        // Work around https://bugzil.la/802326\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(function(track) {\n            track.stop();\n          });\n          throw new DOMException('The object can not be found here.',\n                                 'NotFoundError');\n        }\n        return stream;\n      }, function(e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  }\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    if (browserDetails.version < 44) {\n      return getUserMedia_(constraints, onSuccess, onError);\n    }\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = {\n  shimLocalStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n    }\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\n        var result = null;\n        if (this._localStreams) {\n          this._localStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        if (this._remoteStreams) {\n          this._remoteStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        return result;\n      };\n    }\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        if (this._localStreams.indexOf(stream) === -1) {\n          this._localStreams.push(stream);\n        }\n        var pc = this;\n        stream.getTracks().forEach(function(track) {\n          _addTrack.call(pc, track, stream);\n        });\n      };\n\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (this._localStreams.indexOf(stream) === -1) {\n            this._localStreams.push(stream);\n          }\n        }\n        return _addTrack.call(this, track, stream);\n      };\n    }\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        var index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        var pc = this;\n        var tracks = stream.getTracks();\n        this.getSenders().forEach(function(sender) {\n          if (tracks.indexOf(sender.track) !== -1) {\n            pc.removeTrack(sender);\n          }\n        });\n      };\n    }\n  },\n  shimRemoteStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n    }\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n        get: function() {\n          return this._onaddstream;\n        },\n        set: function(f) {\n          var pc = this;\n          if (this._onaddstream) {\n            this.removeEventListener('addstream', this._onaddstream);\n            this.removeEventListener('track', this._onaddstreampoly);\n          }\n          this.addEventListener('addstream', this._onaddstream = f);\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(function(stream) {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              var event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n      });\n    }\n  },\n  shimCallbacksAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    var prototype = window.RTCPeerConnection.prototype;\n    var createOffer = prototype.createOffer;\n    var createAnswer = prototype.createAnswer;\n    var setLocalDescription = prototype.setLocalDescription;\n    var setRemoteDescription = prototype.setRemoteDescription;\n    var addIceCandidate = prototype.addIceCandidate;\n\n    prototype.createOffer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    prototype.createAnswer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    var withCallback = function(description, successCallback, failureCallback) {\n      var promise = setLocalDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n\n    withCallback = function(description, successCallback, failureCallback) {\n      var promise = setRemoteDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n\n    withCallback = function(candidate, successCallback, failureCallback) {\n      var promise = addIceCandidate.apply(this, [candidate]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n  },\n  shimGetUserMedia: function(window) {\n    var navigator = window && window.navigator;\n\n    if (!navigator.getUserMedia) {\n      if (navigator.webkitGetUserMedia) {\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n      } else if (navigator.mediaDevices &&\n          navigator.mediaDevices.getUserMedia) {\n        navigator.getUserMedia = function(constraints, cb, errcb) {\n          navigator.mediaDevices.getUserMedia(constraints)\n          .then(cb, errcb);\n        }.bind(navigator);\n      }\n    }\n  },\n  shimRTCIceServerUrls: function(window) {\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    var OrigPeerConnection = window.RTCPeerConnection;\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        var newIceServers = [];\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\n          var server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in window.RTCPeerConnection) {\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n  },\n  shimTrackEventTransceiver: function(window) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\n        // defined for some reason even when window.RTCTransceiver is not.\n        !window.RTCTransceiver) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimCreateOfferLegacy: function(window) {\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\n      var pc = this;\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n        }\n        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'audio';\n        });\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          pc.addTransceiver('audio');\n        }\n\n\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n        }\n        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'video';\n        });\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            videoTransceiver.setDirection('sendonly');\n          } else if (videoTransceiver.direction === 'recvonly') {\n            videoTransceiver.setDirection('inactive');\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          pc.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(pc, arguments);\n    };\n  }\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(2);\nvar utils = __webpack_require__(0);\n\nmodule.exports = {\n  shimRTCIceCandidate: function(window) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n        window.RTCIceCandidate.prototype)) {\n      return;\n    }\n\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\n    window.RTCIceCandidate = function(args) {\n      // Remove the a= which shouldn't be part of the candidate string.\n      if (typeof args === 'object' && args.candidate &&\n          args.candidate.indexOf('a=') === 0) {\n        args = JSON.parse(JSON.stringify(args));\n        args.candidate = args.candidate.substr(2);\n      }\n\n      if (args.candidate && args.candidate.length) {\n        // Augment the native candidate with the parsed fields.\n        var nativeCandidate = new NativeRTCIceCandidate(args);\n        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n        var augmentedCandidate = Object.assign(nativeCandidate,\n            parsedCandidate);\n\n        // Add a serializer that does not serialize the extra attributes.\n        augmentedCandidate.toJSON = function() {\n          return {\n            candidate: augmentedCandidate.candidate,\n            sdpMid: augmentedCandidate.sdpMid,\n            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n            usernameFragment: augmentedCandidate.usernameFragment,\n          };\n        };\n        return augmentedCandidate;\n      }\n      return new NativeRTCIceCandidate(args);\n    };\n    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {\n      if (e.candidate) {\n        Object.defineProperty(e, 'candidate', {\n          value: new window.RTCIceCandidate(e.candidate),\n          writable: 'false'\n        });\n      }\n      return e;\n    });\n  },\n\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\n\n  shimCreateObjectURL: function(window) {\n    var URL = window && window.URL;\n\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\n          'srcObject' in window.HTMLMediaElement.prototype &&\n        URL.createObjectURL && URL.revokeObjectURL)) {\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\n      return undefined;\n    }\n\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\n    var streams = new Map(), newId = 0;\n\n    URL.createObjectURL = function(stream) {\n      if ('getTracks' in stream) {\n        var url = 'polyblob:' + (++newId);\n        streams.set(url, stream);\n        utils.deprecated('URL.createObjectURL(stream)',\n            'elem.srcObject = stream');\n        return url;\n      }\n      return nativeCreateObjectURL(stream);\n    };\n    URL.revokeObjectURL = function(url) {\n      nativeRevokeObjectURL(url);\n      streams.delete(url);\n    };\n\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\n                                              'src');\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\n      get: function() {\n        return dsc.get.apply(this);\n      },\n      set: function(url) {\n        this.srcObject = streams.get(url) || null;\n        return dsc.set.apply(this, [url]);\n      }\n    });\n\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n    window.HTMLMediaElement.prototype.setAttribute = function() {\n      if (arguments.length === 2 &&\n          ('' + arguments[0]).toLowerCase() === 'src') {\n        this.srcObject = streams.get(arguments[1]) || null;\n      }\n      return nativeSetAttribute.apply(this, arguments);\n    };\n  },\n\n  shimMaxMessageSize: function(window) {\n    if (window.RTCSctpTransport || !window.RTCPeerConnection) {\n      return;\n    }\n    var browserDetails = utils.detectBrowser(window);\n\n    if (!('sctp' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n        get: function() {\n          return typeof this._sctp === 'undefined' ? null : this._sctp;\n        }\n      });\n    }\n\n    var sctpInDescription = function(description) {\n      var sections = SDPUtils.splitSections(description.sdp);\n      sections.shift();\n      return sections.some(function(mediaSection) {\n        var mLine = SDPUtils.parseMLine(mediaSection);\n        return mLine && mLine.kind === 'application'\n            && mLine.protocol.indexOf('SCTP') !== -1;\n      });\n    };\n\n    var getRemoteFirefoxVersion = function(description) {\n      // TODO: Is there a better solution for detecting Firefox?\n      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n      if (match === null || match.length < 2) {\n        return -1;\n      }\n      var version = parseInt(match[1], 10);\n      // Test for NaN (yes, this is ugly)\n      return version !== version ? -1 : version;\n    };\n\n    var getCanSendMaxMessageSize = function(remoteIsFirefox) {\n      // Every implementation we know can send at least 64 KiB.\n      // Note: Although Chrome is technically able to send up to 256 KiB, the\n      //       data does not reach the other peer reliably.\n      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n      var canSendMaxMessageSize = 65536;\n      if (browserDetails.browser === 'firefox') {\n        if (browserDetails.version < 57) {\n          if (remoteIsFirefox === -1) {\n            // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n            // fragmentation.\n            canSendMaxMessageSize = 16384;\n          } else {\n            // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n            // messages. Thus, supporting ~2 GiB when sending.\n            canSendMaxMessageSize = 2147483637;\n          }\n        } else if (browserDetails.version < 60) {\n          // Currently, all FF >= 57 will reset the remote maximum message size\n          // to the default value when a data channel is created at a later\n          // stage. :(\n          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n          canSendMaxMessageSize =\n            browserDetails.version === 57 ? 65535 : 65536;\n        } else {\n          // FF >= 60 supports sending ~2 GiB\n          canSendMaxMessageSize = 2147483637;\n        }\n      }\n      return canSendMaxMessageSize;\n    };\n\n    var getMaxMessageSize = function(description, remoteIsFirefox) {\n      // Note: 65536 bytes is the default value from the SDP spec. Also,\n      //       every implementation we know supports receiving 65536 bytes.\n      var maxMessageSize = 65536;\n\n      // FF 57 has a slightly incorrect default remote max message size, so\n      // we need to adjust it here to avoid a failure when sending.\n      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n      if (browserDetails.browser === 'firefox'\n           && browserDetails.version === 57) {\n        maxMessageSize = 65535;\n      }\n\n      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n      if (match.length > 0) {\n        maxMessageSize = parseInt(match[0].substr(19), 10);\n      } else if (browserDetails.browser === 'firefox' &&\n                  remoteIsFirefox !== -1) {\n        // If the maximum message size is not present in the remote SDP and\n        // both local and remote are Firefox, the remote peer can receive\n        // ~2 GiB.\n        maxMessageSize = 2147483637;\n      }\n      return maxMessageSize;\n    };\n\n    var origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      var pc = this;\n      pc._sctp = null;\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        var isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        var canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        var maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        var sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get: function() {\n            return maxMessageSize;\n          }\n        });\n        pc._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  },\n\n  shimSendThrowTypeError: function(window) {\n    if (!(window.RTCPeerConnection &&\n        'createDataChannel' in window.RTCPeerConnection.prototype)) {\n      return;\n    }\n\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n    function wrapDcSend(dc, pc) {\n      var origDataChannelSend = dc.send;\n      dc.send = function() {\n        var data = arguments[0];\n        var length = data.length || data.size || data.byteLength;\n        if (dc.readyState === 'open' &&\n            pc.sctp && length > pc.sctp.maxMessageSize) {\n          throw new TypeError('Message too large (can send a maximum of ' +\n            pc.sctp.maxMessageSize + ' bytes)');\n        }\n        return origDataChannelSend.apply(dc, arguments);\n      };\n    }\n    var origCreateDataChannel =\n      window.RTCPeerConnection.prototype.createDataChannel;\n    window.RTCPeerConnection.prototype.createDataChannel = function() {\n      var pc = this;\n      var dataChannel = origCreateDataChannel.apply(pc, arguments);\n      wrapDcSend(dataChannel, pc);\n      return dataChannel;\n    };\n    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {\n      wrapDcSend(e.channel, e.target);\n      return e;\n    });\n  }\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Scanner_vue__ = __webpack_require__(3);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_047f45f1_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Scanner_vue__ = __webpack_require__(25);\nfunction injectStyle (ssrContext) {\n  __webpack_require__(18)\n}\nvar normalizeComponent = __webpack_require__(23)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-047f45f1\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Scanner_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_047f45f1_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Scanner_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(19);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(21)(\"216da832\", content, true, {});\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(20)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".viewport[data-v-047f45f1]{position:relative}.viewport canvas[data-v-047f45f1],.viewport video[data-v-047f45f1]{position:absolute;left:0;top:0}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(22)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"viewport scanner\",attrs:{\"id\":\"interactive\"}},[_c('video'),_vm._v(\" \"),_c('canvas',{staticClass:\"drawingBuffer\"})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// vue-quagga.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ab17106bd6957dae6703","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object.\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  var nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    var wrappedCallback = function(e) {\n      cb(wrapper(e));\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  var nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    var unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get: function() {\n      return this['_on' + eventNameToWrap];\n    },\n    set: function(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\n// Utility methods.\nmodule.exports = {\n  extractVersion: extractVersion,\n  wrapPeerConnectionEvent: wrapPeerConnectionEvent,\n  disableLog: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return (bool) ? 'adapter.js logging disabled' :\n        'adapter.js logging enabled';\n  },\n\n  /**\n   * Disable or enable deprecation warnings\n   * @param {!boolean} bool set to true to disable warnings.\n   */\n  disableWarnings: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n  },\n\n  log: function() {\n    if (typeof window === 'object') {\n      if (logDisabled_) {\n        return;\n      }\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  },\n\n  /**\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\n   */\n  deprecated: function(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n      return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n        ' instead.');\n  },\n\n  /**\n   * Browser detector.\n   *\n   * @return {object} result containing browser and version\n   *     properties.\n   */\n  detectBrowser: function(window) {\n    var navigator = window && window.navigator;\n\n    // Returned result object.\n    var result = {};\n    result.browser = null;\n    result.version = null;\n\n    // Fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a browser.';\n      return result;\n    }\n\n    if (navigator.mozGetUserMedia) { // Firefox.\n      result.browser = 'firefox';\n      result.version = extractVersion(navigator.userAgent,\n          /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome, Chromium, Webview, Opera.\n      // Version matches Chrome/WebRTC version.\n      result.browser = 'chrome';\n      result.version = extractVersion(navigator.userAgent,\n          /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (navigator.mediaDevices &&\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n      result.browser = 'edge';\n      result.version = extractVersion(navigator.userAgent,\n          /Edge\\/(\\d+).(\\d+)$/, 2);\n    } else if (window.RTCPeerConnection &&\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n      result.browser = 'safari';\n      result.version = extractVersion(navigator.userAgent,\n          /AppleWebKit\\/(\\d+)\\./, 1);\n    } else { // Default fallthrough: not supported.\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    return result;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/utils.js\n// module id = 0\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0"," /* eslint-env node */\n'use strict';\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n}\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n}\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.substr(17).split(' ');\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: secondarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  var cname;\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n}\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/sdp/sdp.js\n// module id = 2\n// module chunks = 0","<template>\n  <div id=\"interactive\" class=\"viewport scanner\">\n    <video></video>\n    <canvas class=\"drawingBuffer\"></canvas>\n  </div>\n</template>\n\n<script>\n  import Quagga from 'quagga';\n\n  export default {\n    name: \"scanner\",\n    props: {\n      onDetected: {\n        type: Function,\n      },\n      onProcessed: {\n        type: Function,\n      },\n      readerType: {\n        type: String,\n        default: 'code_128_reader',\n      },\n      readerSize: {\n        width : {\n          type: Number,\n          default: 640,\n        },\n        height: {\n          type: Number,\n          default: 480,\n        }\n      }\n    },\n    data: function () {\n      return {\n        quaggaState: {\n          inputStream: {\n            type: 'LiveStream',\n            constraints: {\n              width: {min: this.readerSize.width},\n              height: {min: this.readerSize.height},\n              facingMode: 'environment',\n              aspectRatio: {min: 1, max: 2}\n            }\n          },\n          locator: {\n            patchSize: 'medium',\n            halfSample: true\n          },\n          numOfWorkers: 2,\n          frequency: 10,\n          decoder: {\n            readers: [{\n              format: this.readerType,\n              config: {}\n            }]\n          },\n          locate: true\n        },\n      }\n    },\n    mounted: function () {\n      Quagga.init(this.quaggaState, function (err) {\n        if (err) {\n          return console.log(err);\n        }\n        Quagga.start();\n      });\n      Quagga.onDetected(this.onDetected ? this.onDetected : this._onDetected);\n      Quagga.onProcessed(this.onProcessed ? this.onProcessed : this._onProcessed);\n    },\n    methods: {\n      _onProcessed: function (result) {\n        let drawingCtx = Quagga.canvas.ctx.overlay,\n          drawingCanvas = Quagga.canvas.dom.overlay;\n\n        if (result) {\n          if (result.boxes) {\n            drawingCtx.clearRect(0, 0, parseInt(drawingCanvas.getAttribute(\"width\")), parseInt(drawingCanvas.getAttribute(\"height\")));\n            result.boxes.filter(function (box) {\n              return box !== result.box;\n            }).forEach(function (box) {\n              Quagga.ImageDebug.drawPath(box, {x: 0, y: 1}, drawingCtx, {color: \"green\", lineWidth: 2});\n            });\n          }\n          if (result.box) {\n            Quagga.ImageDebug.drawPath(result.box, {x: 0, y: 1}, drawingCtx, {color: \"#00F\", lineWidth: 2});\n          }\n\n          if (result.codeResult && result.codeResult.code) {\n            Quagga.ImageDebug.drawPath(result.line, {x: 'x', y: 'y'}, drawingCtx, {color: 'red', lineWidth: 3});\n          }\n        }\n      },\n      _onDetected: function (result) {\n        console.log('detected: ', result);\n      },\n    }\n  }\n</script>\n\n<style scoped>\n  .viewport {\n    position: relative;\n  }\n\n  .viewport canvas, .viewport video {\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/Scanner.vue","import 'webrtc-adapter'\nimport QuaggaScanner from \"./Scanner.vue\"\n\nexport const VERSION = '1.0.0';\n\nexport const Scanner = QuaggaScanner;\n// Install the components\nexport function install (Vue) {\n  Vue.component('quagga-scanner', QuaggaScanner);\n}\n\n// Expose the components\nexport { QuaggaScanner }\n\n/* -- Plugin definition & Auto-install -- */\n/* You shouldn't have to modify the code below */\n\n// Plugin\nconst plugin = {\n  /* eslint-disable no-undef */\n  version: VERSION,\n  install,\n}\n\nexport default plugin\n\n// Auto-install\nlet GlobalVue = null\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n'use strict';\n\nvar adapterFactory = require('./adapter_factory.js');\nmodule.exports = adapterFactory({window: global.window});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/adapter_core.js\n// module id = 5\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n'use strict';\n\nvar utils = require('./utils');\n// Shimming starts here.\nmodule.exports = function(dependencies, opts) {\n  var window = dependencies && dependencies.window;\n\n  var options = {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true,\n  };\n\n  for (var key in opts) {\n    if (hasOwnProperty.call(opts, key)) {\n      options[key] = opts[key];\n    }\n  }\n\n  // Utils.\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  // Uncomment the line below if you want logging to occur, including logging\n  // for the switch statement below. Can also be turned on in the browser via\n  // adapter.disableLog(false), but then logging from the switch statement below\n  // will not appear.\n  // require('./utils').disableLog(false);\n\n  // Browser shims.\n  var chromeShim = require('./chrome/chrome_shim') || null;\n  var edgeShim = require('./edge/edge_shim') || null;\n  var firefoxShim = require('./firefox/firefox_shim') || null;\n  var safariShim = require('./safari/safari_shim') || null;\n  var commonShim = require('./common_shim') || null;\n\n  // Export to the adapter global object visible in the browser.\n  var adapter = {\n    browserDetails: browserDetails,\n    commonShim: commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      chromeShim.shimSourceObject(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n      chromeShim.shimSenderReceiverGetStats(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n      commonShim.shimCreateObjectURL(window);\n\n      firefoxShim.shimGetUserMedia(window);\n      firefoxShim.shimSourceObject(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      firefoxShim.shimRemoveStream(window);\n      firefoxShim.shimSenderGetStats(window);\n      firefoxShim.shimReceiverGetStats(window);\n      firefoxShim.shimRTCDataChannel(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      edgeShim.shimGetUserMedia(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n      commonShim.shimCreateObjectURL(window);\n\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimTrackEventTransceiver(window);\n      safariShim.shimGetUserMedia(window);\n      safariShim.shimCreateOfferLegacy(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/adapter_factory.js\n// module id = 6\n// module chunks = 0","\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nvar utils = require('../utils.js');\nvar logging = utils.log;\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(function(name) {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(function(id) {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  var filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  var trackStats = [];\n  result.forEach(function(value) {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(function(trackStat) {\n    result.forEach(function(stats) {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\nmodule.exports = {\n  shimGetUserMedia: require('./getusermedia'),\n  shimMediaStream: function(window) {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n          }\n          this.addEventListener('track', this._ontrack = f);\n        }\n      });\n      var origSetRemoteDescription =\n          window.RTCPeerConnection.prototype.setRemoteDescription;\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n        var pc = this;\n        if (!pc._ontrackpoly) {\n          pc._ontrackpoly = function(e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function(te) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === te.track.id;\n                });\n              } else {\n                receiver = {track: te.track};\n              }\n\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function(track) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === track.id;\n                });\n              } else {\n                receiver = {track: track};\n              }\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n          };\n          pc.addEventListener('addstream', pc._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n    } else if (!('RTCRtpTransceiver' in window)) {\n      utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n        if (!e.transceiver) {\n          e.transceiver = {receiver: e.receiver};\n        }\n        return e;\n      });\n    }\n  },\n\n  shimGetSendersWithDtmf: function(window) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\n      var shimSenderWithDtmf = function(pc, track) {\n        return {\n          track: track,\n          get dtmf() {\n            if (this._dtmf === undefined) {\n              if (track.kind === 'audio') {\n                this._dtmf = pc.createDTMFSender(track);\n              } else {\n                this._dtmf = null;\n              }\n            }\n            return this._dtmf;\n          },\n          _pc: pc\n        };\n      };\n\n      // augment addTrack when getSenders is not available.\n      if (!window.RTCPeerConnection.prototype.getSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          this._senders = this._senders || [];\n          return this._senders.slice(); // return a copy of the internal state.\n        };\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n          var pc = this;\n          var sender = origAddTrack.apply(pc, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(pc, track);\n            pc._senders.push(sender);\n          }\n          return sender;\n        };\n\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n          var pc = this;\n          origRemoveTrack.apply(pc, arguments);\n          var idx = pc._senders.indexOf(sender);\n          if (idx !== -1) {\n            pc._senders.splice(idx, 1);\n          }\n        };\n      }\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origAddStream.apply(pc, [stream]);\n        stream.getTracks().forEach(function(track) {\n          pc._senders.push(shimSenderWithDtmf(pc, track));\n        });\n      };\n\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origRemoveStream.apply(pc, [stream]);\n\n        stream.getTracks().forEach(function(track) {\n          var sender = pc._senders.find(function(s) {\n            return s.track === track;\n          });\n          if (sender) {\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\n          }\n        });\n      };\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\n               'getSenders' in window.RTCPeerConnection.prototype &&\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\n               window.RTCRtpSender &&\n               !('dtmf' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = this._pc.createDTMFSender(this.track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n  },\n\n  shimSenderReceiverGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender && window.RTCRtpReceiver)) {\n      return;\n    }\n\n    // shim sender stats.\n    if (!('getStats' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      if (origGetSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          var pc = this;\n          var senders = origGetSenders.apply(pc, []);\n          senders.forEach(function(sender) {\n            sender._pc = pc;\n          });\n          return senders;\n        };\n      }\n\n      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      if (origAddTrack) {\n        window.RTCPeerConnection.prototype.addTrack = function() {\n          var sender = origAddTrack.apply(this, arguments);\n          sender._pc = this;\n          return sender;\n        };\n      }\n      window.RTCRtpSender.prototype.getStats = function() {\n        var sender = this;\n        return this._pc.getStats().then(function(result) {\n          /* Note: this will include stats of all senders that\n           *   send a track with the same id as sender.track as\n           *   it is not possible to identify the RTCRtpSender.\n           */\n          return filterStats(result, sender.track, true);\n        });\n      };\n    }\n\n    // shim receiver stats.\n    if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n      if (origGetReceivers) {\n        window.RTCPeerConnection.prototype.getReceivers = function() {\n          var pc = this;\n          var receivers = origGetReceivers.apply(pc, []);\n          receivers.forEach(function(receiver) {\n            receiver._pc = pc;\n          });\n          return receivers;\n        };\n      }\n      utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n        e.receiver._pc = e.srcElement;\n        return e;\n      });\n      window.RTCRtpReceiver.prototype.getStats = function() {\n        var receiver = this;\n        return this._pc.getStats().then(function(result) {\n          return filterStats(result, receiver.track, false);\n        });\n      };\n    }\n\n    if (!('getStats' in window.RTCRtpSender.prototype &&\n        'getStats' in window.RTCRtpReceiver.prototype)) {\n      return;\n    }\n\n    // shim RTCPeerConnection.getStats(track).\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function() {\n      var pc = this;\n      if (arguments.length > 0 &&\n          arguments[0] instanceof window.MediaStreamTrack) {\n        var track = arguments[0];\n        var sender;\n        var receiver;\n        var err;\n        pc.getSenders().forEach(function(s) {\n          if (s.track === track) {\n            if (sender) {\n              err = true;\n            } else {\n              sender = s;\n            }\n          }\n        });\n        pc.getReceivers().forEach(function(r) {\n          if (r.track === track) {\n            if (receiver) {\n              err = true;\n            } else {\n              receiver = r;\n            }\n          }\n          return r.track === track;\n        });\n        if (err || (sender && receiver)) {\n          return Promise.reject(new DOMException(\n            'There are more than one sender or receiver for the track.',\n            'InvalidAccessError'));\n        } else if (sender) {\n          return sender.getStats();\n        } else if (receiver) {\n          return receiver.getStats();\n        }\n        return Promise.reject(new DOMException(\n          'There is no sender or receiver for the track.',\n          'InvalidAccessError'));\n      }\n      return origGetStats.apply(pc, arguments);\n    };\n  },\n\n  shimSourceObject: function(window) {\n    var URL = window && window.URL;\n\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this._srcObject;\n          },\n          set: function(stream) {\n            var self = this;\n            // Use _srcObject as a private property for this shim\n            this._srcObject = stream;\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return undefined;\n            }\n            this.src = URL.createObjectURL(stream);\n            // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n            stream.addEventListener('addtrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n\n  shimAddTrackRemoveTrackWithNative: function(window) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {\n        return pc._shimmedLocalStreams[streamId][0];\n      });\n    };\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      var sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      var existingSenders = pc.getSenders();\n      origAddStream.apply(this, arguments);\n      var newSenders = pc.getSenders().filter(function(newSender) {\n        return existingSenders.indexOf(newSender) === -1;\n      });\n      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {\n          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            pc._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (pc._shimmedLocalStreams[streamId].length === 1) {\n            delete pc._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n  },\n\n  shimAddTrackRemoveTrack: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n    // shim addTrack and removeTrack.\n    if (window.RTCPeerConnection.prototype.addTrack &&\n        browserDetails.version >= 65) {\n      return this.shimAddTrackRemoveTrackWithNative(window);\n    }\n\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\n        .getLocalStreams;\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      var nativeStreams = origGetLocalStreams.apply(this);\n      pc._reverseStreams = pc._reverseStreams || {};\n      return nativeStreams.map(function(stream) {\n        return pc._reverseStreams[stream.id];\n      });\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      // Add identity mapping for consistency with addTrack.\n      // Unless this is being used with a stream from addTrack.\n      if (!pc._reverseStreams[stream.id]) {\n        var newStream = new window.MediaStream(stream.getTracks());\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        stream = newStream;\n      }\n      origAddStream.apply(pc, [stream]);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\n          pc._streams[stream.id].id : stream.id)];\n      delete pc._streams[stream.id];\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      var streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(function(t) {\n            return t === track;\n          })) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      var alreadyExists = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n      var oldStream = pc._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(function() {\n          pc.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        var newStream = new window.MediaStream([track]);\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        pc.addStream(newStream);\n      }\n      return pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n    };\n\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n            externalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    function replaceExternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n            internalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    ['createOffer', 'createAnswer'].forEach(function(method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function() {\n        var pc = this;\n        var args = arguments;\n        var isLegacyCall = arguments.length &&\n            typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(pc, [\n            function(description) {\n              var desc = replaceInternalStreamId(pc, description);\n              args[0].apply(null, [desc]);\n            },\n            function(err) {\n              if (args[1]) {\n                args[1].apply(null, err);\n              }\n            }, arguments[2]\n          ]);\n        }\n        return nativeMethod.apply(pc, arguments)\n        .then(function(description) {\n          return replaceInternalStreamId(pc, description);\n        });\n      };\n    });\n\n    var origSetLocalDescription =\n        window.RTCPeerConnection.prototype.setLocalDescription;\n    window.RTCPeerConnection.prototype.setLocalDescription = function() {\n      var pc = this;\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(pc, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\n      return origSetLocalDescription.apply(pc, arguments);\n    };\n\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n    var origLocalDescription = Object.getOwnPropertyDescriptor(\n        window.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window.RTCPeerConnection.prototype,\n        'localDescription', {\n          get: function() {\n            var pc = this;\n            var description = origLocalDescription.get.apply(this);\n            if (description.type === '') {\n              return description;\n            }\n            return replaceInternalStreamId(pc, description);\n          }\n        });\n\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      var isLocal = sender._pc === pc;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      pc._streams = pc._streams || {};\n      var stream;\n      Object.keys(pc._streams).forEach(function(streamid) {\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\n          return sender.track === track;\n        });\n        if (hasTrack) {\n          stream = pc._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          pc.removeStream(pc._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.webkitRTCPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      if (window.webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n    } else {\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n      var OrigPeerConnection = window.RTCPeerConnection;\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n          var newIceServers = [];\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\n            var server = pcConfig.iceServers[i];\n            if (!server.hasOwnProperty('urls') &&\n                server.hasOwnProperty('url')) {\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n              server = JSON.parse(JSON.stringify(server));\n              server.urls = server.url;\n              newIceServers.push(server);\n            } else {\n              newIceServers.push(pcConfig.iceServers[i]);\n            }\n          }\n          pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(selector,\n        successCallback, errorCallback) {\n      var pc = this;\n      var args = arguments;\n\n      // If selector is a function then we are in the old style stats so just\n      // pass back the original getStats format to avoid breaking old users.\n      if (arguments.length > 0 && typeof selector === 'function') {\n        return origGetStats.apply(this, arguments);\n      }\n\n      // When spec-style getStats is supported, return those when called with\n      // either no arguments or the selector argument is null.\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\n          typeof arguments[0] !== 'function')) {\n        return origGetStats.apply(this, []);\n      }\n\n      var fixChromeStats_ = function(response) {\n        var standardReport = {};\n        var reports = response.result();\n        reports.forEach(function(report) {\n          var standardStats = {\n            id: report.id,\n            timestamp: report.timestamp,\n            type: {\n              localcandidate: 'local-candidate',\n              remotecandidate: 'remote-candidate'\n            }[report.type] || report.type\n          };\n          report.names().forEach(function(name) {\n            standardStats[name] = report.stat(name);\n          });\n          standardReport[standardStats.id] = standardStats;\n        });\n\n        return standardReport;\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function(stats) {\n        return new Map(Object.keys(stats).map(function(key) {\n          return [key, stats[key]];\n        }));\n      };\n\n      if (arguments.length >= 2) {\n        var successCallbackWrapper_ = function(response) {\n          args[1](makeMapStats(fixChromeStats_(response)));\n        };\n\n        return origGetStats.apply(this, [successCallbackWrapper_,\n          arguments[0]]);\n      }\n\n      // promise-support\n      return new Promise(function(resolve, reject) {\n        origGetStats.apply(pc, [\n          function(response) {\n            resolve(makeMapStats(fixChromeStats_(response)));\n          }, reject]);\n      }).then(successCallback, errorCallback);\n    };\n\n    // add promise support -- natively available in Chrome 51\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\n            window.RTCPeerConnection.prototype[method] = function() {\n              var args = arguments;\n              var pc = this;\n              var promise = new Promise(function(resolve, reject) {\n                nativeMethod.apply(pc, [args[0], resolve, reject]);\n              });\n              if (args.length < 2) {\n                return promise;\n              }\n              return promise.then(function() {\n                args[1].apply(null, []);\n              },\n              function(err) {\n                if (args.length >= 3) {\n                  args[2].apply(null, [err]);\n                }\n              });\n            };\n          });\n    }\n\n    // promise support for createOffer and createAnswer. Available (without\n    // bugs) since M52: crbug/619289\n    if (browserDetails.version < 52) {\n      ['createOffer', 'createAnswer'].forEach(function(method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          var pc = this;\n          if (arguments.length < 1 || (arguments.length === 1 &&\n              typeof arguments[0] === 'object')) {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function(resolve, reject) {\n              nativeMethod.apply(pc, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n    }\n\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\n// module id = 7\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nvar utils = require('../utils.js');\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n\n  var constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function(key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function(mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      var remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      var getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(function(devices) {\n            devices = devices.filter(function(d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function(d) {\n              return matches.some(function(match) {\n                return d.label.toLowerCase().indexOf(match) !== -1;\n              });\n            });\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraintName,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function(c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_;\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  };\n\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {\n      getUserMedia: getUserMediaPromise_,\n      enumerateDevices: function() {\n        return new Promise(function(resolve) {\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\n          return window.MediaStreamTrack.getSources(function(devices) {\n            resolve(devices.map(function(device) {\n              return {label: device.label,\n                kind: kinds[device.kind],\n                deviceId: device.id,\n                groupId: ''};\n            }));\n          });\n        });\n      },\n      getSupportedConstraints: function() {\n        return {\n          deviceId: true, echoCancellation: true, facingMode: true,\n          frameRate: true, height: true, width: true\n        };\n      }\n    };\n  }\n\n  // A shim for getUserMedia method on the mediaDevices object.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (!navigator.mediaDevices.getUserMedia) {\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return getUserMediaPromise_(constraints);\n    };\n  } else {\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, function(c) {\n        return origGetUserMedia(c).then(function(stream) {\n          if (c.audio && !stream.getAudioTracks().length ||\n              c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function(track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function(e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n\n  // Dummy devicechange event methods.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n    navigator.mediaDevices.addEventListener = function() {\n      logging('Dummy mediaDevices.addEventListener called.');\n    };\n  }\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n    navigator.mediaDevices.removeEventListener = function() {\n      logging('Dummy mediaDevices.removeEventListener called.');\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\n// module id = 8\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar utils = require('../utils');\nvar filterIceServers = require('./filtericeservers');\nvar shimRTCPeerConnection = require('rtcpeerconnection-shim');\n\nmodule.exports = {\n  shimGetUserMedia: require('./getusermedia'),\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (window.RTCIceGatherer) {\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function(args) {\n          return args;\n        };\n      }\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function(args) {\n          return args;\n        };\n      }\n      // this adds an additional event listener to MediaStrackTrack that signals\n      // when a tracks enabled property was changed. Workaround for a bug in\n      // addStream, see below. No longer required in 15025+\n      if (browserDetails.version < 15025) {\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\n            window.MediaStreamTrack.prototype, 'enabled');\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n          set: function(value) {\n            origMSTEnabled.set.call(this, value);\n            var ev = new Event('enabled');\n            ev.enabled = value;\n            this.dispatchEvent(ev);\n          }\n        });\n      }\n    }\n\n    // ORTC defines the DTMF sender a bit different.\n    // https://github.com/w3c/ortc/issues/714\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = new window.RTCDtmfSender(this);\n            } else if (this.track.kind === 'video') {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n    // Edge currently only implements the RTCDtmfSender, not the\n    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n    if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n      window.RTCDTMFSender = window.RTCDtmfSender;\n    }\n\n    var RTCPeerConnectionShim = shimRTCPeerConnection(window,\n        browserDetails.version);\n    window.RTCPeerConnection = function(config) {\n      if (config && config.iceServers) {\n        config.iceServers = filterIceServers(config.iceServers);\n      }\n      return new RTCPeerConnectionShim(config);\n    };\n    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n  },\n  shimReplaceTrack: function(window) {\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n    if (window.RTCRtpSender &&\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\n      window.RTCRtpSender.prototype.replaceTrack =\n          window.RTCRtpSender.prototype.setTrack;\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/edge/edge_shim.js\n// module id = 9\n// module chunks = 0","/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar utils = require('../utils');\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nmodule.exports = function(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js\n// module id = 10\n// module chunks = 0","/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp');\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all field are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this.localDescription = null;\n    this.remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // dpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc.localDescription.sdp =\n          SDPUtils.getDescription(pc.localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if ((kind === 'application' && protocol === 'DTLS/SCTP') || rejected) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc.remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc.remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\n// module id = 11\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(function(e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/edge/getusermedia.js\n// module id = 12\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = {\n  shimGetUserMedia: require('./getusermedia'),\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\n            e.stream.getTracks().forEach(function(track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = {track: track};\n              event.transceiver = {receiver: event.receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n    if (typeof window === 'object' && window.RTCTrackEvent &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        !('transceiver' in window.RTCTrackEvent.prototype)) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this.mozSrcObject;\n          },\n          set: function(stream) {\n            this.mozSrcObject = stream;\n          }\n        });\n      }\n    }\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n        window.mozRTCPeerConnection)) {\n      return; // probably media.peerconnection.enabled=false in about:config\n    }\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (browserDetails.version < 38) {\n          // .urls is not supported in FF < 38.\n          // create RTCIceServers with a single url.\n          if (pcConfig && pcConfig.iceServers) {\n            var newIceServers = [];\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\n              var server = pcConfig.iceServers[i];\n              if (server.hasOwnProperty('urls')) {\n                for (var j = 0; j < server.urls.length; j++) {\n                  var newServer = {\n                    url: server.urls[j]\n                  };\n                  if (server.urls[j].indexOf('turn') === 0) {\n                    newServer.username = server.username;\n                    newServer.credential = server.credential;\n                  }\n                  newIceServers.push(newServer);\n                }\n              } else {\n                newIceServers.push(pcConfig.iceServers[i]);\n              }\n            }\n            pcConfig.iceServers = newIceServers;\n          }\n        }\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.mozRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (window.mozRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.mozRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\n    }\n\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function(stats) {\n      var map = new Map();\n      Object.keys(stats).forEach(function(key) {\n        map.set(key, stats[key]);\n        map[key] = stats[key];\n      });\n      return map;\n    };\n\n    var modernStatsTypes = {\n      inboundrtp: 'inbound-rtp',\n      outboundrtp: 'outbound-rtp',\n      candidatepair: 'candidate-pair',\n      localcandidate: 'local-candidate',\n      remotecandidate: 'remote-candidate'\n    };\n\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(\n      selector,\n      onSucc,\n      onErr\n    ) {\n      return nativeGetStats.apply(this, [selector || null])\n        .then(function(stats) {\n          if (browserDetails.version < 48) {\n            stats = makeMapStats(stats);\n          }\n          if (browserDetails.version < 53 && !onSucc) {\n            // Shim only promise getStats with spec-hyphens in type names\n            // Leave callback version alone; misc old uses of forEach before Map\n            try {\n              stats.forEach(function(stat) {\n                stat.type = modernStatsTypes[stat.type] || stat.type;\n              });\n            } catch (e) {\n              if (e.name !== 'TypeError') {\n                throw e;\n              }\n              // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n              stats.forEach(function(stat, i) {\n                stats.set(i, Object.assign({}, stat, {\n                  type: modernStatsTypes[stat.type] || stat.type\n                }));\n              });\n            }\n          }\n          return stats;\n        })\n        .then(onSucc, onErr);\n    };\n  },\n\n  shimSenderGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n      return;\n    }\n    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n    }\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function() {\n        var sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function() {\n      return this.track ? this._pc.getStats(this.track) :\n          Promise.resolve(new Map());\n    };\n  },\n\n  shimReceiverGetStats: function(window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection &&\n        window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n      return;\n    }\n    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function() {\n        var pc = this;\n        var receivers = origGetReceivers.apply(pc, []);\n        receivers.forEach(function(receiver) {\n          receiver._pc = pc;\n        });\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function() {\n      return this._pc.getStats(this.track);\n    };\n  },\n\n  shimRemoveStream: function(window) {\n    if (!window.RTCPeerConnection ||\n        'removeStream' in window.RTCPeerConnection.prototype) {\n      return;\n    }\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(function(sender) {\n        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {\n          pc.removeTrack(sender);\n        }\n      });\n    };\n  },\n\n  shimRTCDataChannel: function(window) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window.DataChannel && !window.RTCDataChannel) {\n      window.RTCDataChannel = window.DataChannel;\n    }\n  },\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\n// module id = 13\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar utils = require('../utils');\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        InternalError: 'NotReadableError',\n        NotSupportedError: 'TypeError',\n        PermissionDeniedError: 'NotAllowedError',\n        SecurityError: 'NotAllowedError'\n      }[e.name] || e.name,\n      message: {\n        'The operation is insecure.': 'The request is not allowed by the ' +\n        'user agent or the platform in the current context.'\n      }[e.message] || e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  // getUserMedia constraints shim.\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    var constraintsToFF37_ = function(c) {\n      if (typeof c !== 'object' || c.require) {\n        return c;\n      }\n      var require = [];\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = c[key] = (typeof c[key] === 'object') ?\n            c[key] : {ideal: c[key]};\n        if (r.min !== undefined ||\n            r.max !== undefined || r.exact !== undefined) {\n          require.push(key);\n        }\n        if (r.exact !== undefined) {\n          if (typeof r.exact === 'number') {\n            r. min = r.max = r.exact;\n          } else {\n            c[key] = r.exact;\n          }\n          delete r.exact;\n        }\n        if (r.ideal !== undefined) {\n          c.advanced = c.advanced || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[key] = {min: r.ideal, max: r.ideal};\n          } else {\n            oc[key] = r.ideal;\n          }\n          c.advanced.push(oc);\n          delete r.ideal;\n          if (!Object.keys(r).length) {\n            delete c[key];\n          }\n        }\n      });\n      if (require.length) {\n        c.require = require;\n      }\n      return c;\n    };\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (browserDetails.version < 38) {\n      logging('spec: ' + JSON.stringify(constraints));\n      if (constraints.audio) {\n        constraints.audio = constraintsToFF37_(constraints.audio);\n      }\n      if (constraints.video) {\n        constraints.video = constraintsToFF37_(constraints.video);\n      }\n      logging('ff37: ' + JSON.stringify(constraints));\n    }\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n      onError(shimError_(e));\n    });\n  };\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      getUserMedia_(constraints, resolve, reject);\n    });\n  };\n\n  // Shim for mediaDevices on older versions.\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n      addEventListener: function() { },\n      removeEventListener: function() { }\n    };\n  }\n  navigator.mediaDevices.enumerateDevices =\n      navigator.mediaDevices.enumerateDevices || function() {\n        return new Promise(function(resolve) {\n          var infos = [\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n          ];\n          resolve(infos);\n        });\n      };\n\n  if (browserDetails.version < 41) {\n    // Work around http://bugzil.la/1169665\n    var orgEnumerateDevices =\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n    navigator.mediaDevices.enumerateDevices = function() {\n      return orgEnumerateDevices().then(undefined, function(e) {\n        if (e.name === 'NotFoundError') {\n          return [];\n        }\n        throw e;\n      });\n    };\n  }\n  if (browserDetails.version < 49) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      return origGetUserMedia(c).then(function(stream) {\n        // Work around https://bugzil.la/802326\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(function(track) {\n            track.stop();\n          });\n          throw new DOMException('The object can not be found here.',\n                                 'NotFoundError');\n        }\n        return stream;\n      }, function(e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  }\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    if (browserDetails.version < 44) {\n      return getUserMedia_(constraints, onSuccess, onError);\n    }\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\n// module id = 14\n// module chunks = 0","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n'use strict';\nvar utils = require('../utils');\n\nmodule.exports = {\n  shimLocalStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n    }\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\n        var result = null;\n        if (this._localStreams) {\n          this._localStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        if (this._remoteStreams) {\n          this._remoteStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        return result;\n      };\n    }\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        if (this._localStreams.indexOf(stream) === -1) {\n          this._localStreams.push(stream);\n        }\n        var pc = this;\n        stream.getTracks().forEach(function(track) {\n          _addTrack.call(pc, track, stream);\n        });\n      };\n\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (this._localStreams.indexOf(stream) === -1) {\n            this._localStreams.push(stream);\n          }\n        }\n        return _addTrack.call(this, track, stream);\n      };\n    }\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        var index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        var pc = this;\n        var tracks = stream.getTracks();\n        this.getSenders().forEach(function(sender) {\n          if (tracks.indexOf(sender.track) !== -1) {\n            pc.removeTrack(sender);\n          }\n        });\n      };\n    }\n  },\n  shimRemoteStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n    }\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n        get: function() {\n          return this._onaddstream;\n        },\n        set: function(f) {\n          var pc = this;\n          if (this._onaddstream) {\n            this.removeEventListener('addstream', this._onaddstream);\n            this.removeEventListener('track', this._onaddstreampoly);\n          }\n          this.addEventListener('addstream', this._onaddstream = f);\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(function(stream) {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              var event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n      });\n    }\n  },\n  shimCallbacksAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    var prototype = window.RTCPeerConnection.prototype;\n    var createOffer = prototype.createOffer;\n    var createAnswer = prototype.createAnswer;\n    var setLocalDescription = prototype.setLocalDescription;\n    var setRemoteDescription = prototype.setRemoteDescription;\n    var addIceCandidate = prototype.addIceCandidate;\n\n    prototype.createOffer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    prototype.createAnswer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    var withCallback = function(description, successCallback, failureCallback) {\n      var promise = setLocalDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n\n    withCallback = function(description, successCallback, failureCallback) {\n      var promise = setRemoteDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n\n    withCallback = function(candidate, successCallback, failureCallback) {\n      var promise = addIceCandidate.apply(this, [candidate]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n  },\n  shimGetUserMedia: function(window) {\n    var navigator = window && window.navigator;\n\n    if (!navigator.getUserMedia) {\n      if (navigator.webkitGetUserMedia) {\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n      } else if (navigator.mediaDevices &&\n          navigator.mediaDevices.getUserMedia) {\n        navigator.getUserMedia = function(constraints, cb, errcb) {\n          navigator.mediaDevices.getUserMedia(constraints)\n          .then(cb, errcb);\n        }.bind(navigator);\n      }\n    }\n  },\n  shimRTCIceServerUrls: function(window) {\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    var OrigPeerConnection = window.RTCPeerConnection;\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        var newIceServers = [];\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\n          var server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in window.RTCPeerConnection) {\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n  },\n  shimTrackEventTransceiver: function(window) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\n        // defined for some reason even when window.RTCTransceiver is not.\n        !window.RTCTransceiver) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimCreateOfferLegacy: function(window) {\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\n      var pc = this;\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n        }\n        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'audio';\n        });\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          pc.addTransceiver('audio');\n        }\n\n\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n        }\n        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'video';\n        });\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            videoTransceiver.setDirection('sendonly');\n          } else if (videoTransceiver.direction === 'recvonly') {\n            videoTransceiver.setDirection('inactive');\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          pc.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(pc, arguments);\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\n// module id = 15\n// module chunks = 0","/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp');\nvar utils = require('./utils');\n\nmodule.exports = {\n  shimRTCIceCandidate: function(window) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n        window.RTCIceCandidate.prototype)) {\n      return;\n    }\n\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\n    window.RTCIceCandidate = function(args) {\n      // Remove the a= which shouldn't be part of the candidate string.\n      if (typeof args === 'object' && args.candidate &&\n          args.candidate.indexOf('a=') === 0) {\n        args = JSON.parse(JSON.stringify(args));\n        args.candidate = args.candidate.substr(2);\n      }\n\n      if (args.candidate && args.candidate.length) {\n        // Augment the native candidate with the parsed fields.\n        var nativeCandidate = new NativeRTCIceCandidate(args);\n        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n        var augmentedCandidate = Object.assign(nativeCandidate,\n            parsedCandidate);\n\n        // Add a serializer that does not serialize the extra attributes.\n        augmentedCandidate.toJSON = function() {\n          return {\n            candidate: augmentedCandidate.candidate,\n            sdpMid: augmentedCandidate.sdpMid,\n            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n            usernameFragment: augmentedCandidate.usernameFragment,\n          };\n        };\n        return augmentedCandidate;\n      }\n      return new NativeRTCIceCandidate(args);\n    };\n    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {\n      if (e.candidate) {\n        Object.defineProperty(e, 'candidate', {\n          value: new window.RTCIceCandidate(e.candidate),\n          writable: 'false'\n        });\n      }\n      return e;\n    });\n  },\n\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\n\n  shimCreateObjectURL: function(window) {\n    var URL = window && window.URL;\n\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\n          'srcObject' in window.HTMLMediaElement.prototype &&\n        URL.createObjectURL && URL.revokeObjectURL)) {\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\n      return undefined;\n    }\n\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\n    var streams = new Map(), newId = 0;\n\n    URL.createObjectURL = function(stream) {\n      if ('getTracks' in stream) {\n        var url = 'polyblob:' + (++newId);\n        streams.set(url, stream);\n        utils.deprecated('URL.createObjectURL(stream)',\n            'elem.srcObject = stream');\n        return url;\n      }\n      return nativeCreateObjectURL(stream);\n    };\n    URL.revokeObjectURL = function(url) {\n      nativeRevokeObjectURL(url);\n      streams.delete(url);\n    };\n\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\n                                              'src');\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\n      get: function() {\n        return dsc.get.apply(this);\n      },\n      set: function(url) {\n        this.srcObject = streams.get(url) || null;\n        return dsc.set.apply(this, [url]);\n      }\n    });\n\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n    window.HTMLMediaElement.prototype.setAttribute = function() {\n      if (arguments.length === 2 &&\n          ('' + arguments[0]).toLowerCase() === 'src') {\n        this.srcObject = streams.get(arguments[1]) || null;\n      }\n      return nativeSetAttribute.apply(this, arguments);\n    };\n  },\n\n  shimMaxMessageSize: function(window) {\n    if (window.RTCSctpTransport || !window.RTCPeerConnection) {\n      return;\n    }\n    var browserDetails = utils.detectBrowser(window);\n\n    if (!('sctp' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n        get: function() {\n          return typeof this._sctp === 'undefined' ? null : this._sctp;\n        }\n      });\n    }\n\n    var sctpInDescription = function(description) {\n      var sections = SDPUtils.splitSections(description.sdp);\n      sections.shift();\n      return sections.some(function(mediaSection) {\n        var mLine = SDPUtils.parseMLine(mediaSection);\n        return mLine && mLine.kind === 'application'\n            && mLine.protocol.indexOf('SCTP') !== -1;\n      });\n    };\n\n    var getRemoteFirefoxVersion = function(description) {\n      // TODO: Is there a better solution for detecting Firefox?\n      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n      if (match === null || match.length < 2) {\n        return -1;\n      }\n      var version = parseInt(match[1], 10);\n      // Test for NaN (yes, this is ugly)\n      return version !== version ? -1 : version;\n    };\n\n    var getCanSendMaxMessageSize = function(remoteIsFirefox) {\n      // Every implementation we know can send at least 64 KiB.\n      // Note: Although Chrome is technically able to send up to 256 KiB, the\n      //       data does not reach the other peer reliably.\n      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n      var canSendMaxMessageSize = 65536;\n      if (browserDetails.browser === 'firefox') {\n        if (browserDetails.version < 57) {\n          if (remoteIsFirefox === -1) {\n            // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n            // fragmentation.\n            canSendMaxMessageSize = 16384;\n          } else {\n            // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n            // messages. Thus, supporting ~2 GiB when sending.\n            canSendMaxMessageSize = 2147483637;\n          }\n        } else if (browserDetails.version < 60) {\n          // Currently, all FF >= 57 will reset the remote maximum message size\n          // to the default value when a data channel is created at a later\n          // stage. :(\n          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n          canSendMaxMessageSize =\n            browserDetails.version === 57 ? 65535 : 65536;\n        } else {\n          // FF >= 60 supports sending ~2 GiB\n          canSendMaxMessageSize = 2147483637;\n        }\n      }\n      return canSendMaxMessageSize;\n    };\n\n    var getMaxMessageSize = function(description, remoteIsFirefox) {\n      // Note: 65536 bytes is the default value from the SDP spec. Also,\n      //       every implementation we know supports receiving 65536 bytes.\n      var maxMessageSize = 65536;\n\n      // FF 57 has a slightly incorrect default remote max message size, so\n      // we need to adjust it here to avoid a failure when sending.\n      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n      if (browserDetails.browser === 'firefox'\n           && browserDetails.version === 57) {\n        maxMessageSize = 65535;\n      }\n\n      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n      if (match.length > 0) {\n        maxMessageSize = parseInt(match[0].substr(19), 10);\n      } else if (browserDetails.browser === 'firefox' &&\n                  remoteIsFirefox !== -1) {\n        // If the maximum message size is not present in the remote SDP and\n        // both local and remote are Firefox, the remote peer can receive\n        // ~2 GiB.\n        maxMessageSize = 2147483637;\n      }\n      return maxMessageSize;\n    };\n\n    var origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      var pc = this;\n      pc._sctp = null;\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        var isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        var canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        var maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        var sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get: function() {\n            return maxMessageSize;\n          }\n        });\n        pc._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  },\n\n  shimSendThrowTypeError: function(window) {\n    if (!(window.RTCPeerConnection &&\n        'createDataChannel' in window.RTCPeerConnection.prototype)) {\n      return;\n    }\n\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n    function wrapDcSend(dc, pc) {\n      var origDataChannelSend = dc.send;\n      dc.send = function() {\n        var data = arguments[0];\n        var length = data.length || data.size || data.byteLength;\n        if (dc.readyState === 'open' &&\n            pc.sctp && length > pc.sctp.maxMessageSize) {\n          throw new TypeError('Message too large (can send a maximum of ' +\n            pc.sctp.maxMessageSize + ' bytes)');\n        }\n        return origDataChannelSend.apply(dc, arguments);\n      };\n    }\n    var origCreateDataChannel =\n      window.RTCPeerConnection.prototype.createDataChannel;\n    window.RTCPeerConnection.prototype.createDataChannel = function() {\n      var pc = this;\n      var dataChannel = origCreateDataChannel.apply(pc, arguments);\n      wrapDcSend(dataChannel, pc);\n      return dataChannel;\n    };\n    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {\n      wrapDcSend(e.channel, e.target);\n      return e;\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/webrtc-adapter/src/js/common_shim.js\n// module id = 16\n// module chunks = 0","function injectStyle (ssrContext) {\n  require(\"!!vue-style-loader!css-loader?minimize!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-047f45f1\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./Scanner.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Scanner.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Scanner.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-047f45f1\\\",\\\"hasScoped\\\":true,\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./Scanner.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-047f45f1\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Scanner.vue\n// module id = 17\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?minimize!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-047f45f1\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Scanner.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"216da832\", content, true, {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader!./node_modules/css-loader?minimize!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-047f45f1\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/Scanner.vue\n// module id = 18\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".viewport[data-v-047f45f1]{position:relative}.viewport canvas[data-v-047f45f1],.viewport video[data-v-047f45f1]{position:absolute;left:0;top:0}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?minimize!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-047f45f1\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/Scanner.vue\n// module id = 19\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 20\n// module chunks = 0","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader/lib/addStylesClient.js\n// module id = 21\n// module chunks = 0","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-style-loader/lib/listToStyles.js\n// module id = 22\n// module chunks = 0","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/component-normalizer.js\n// module id = 23\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"quagga\"\n// module id = 24\n// module chunks = 0","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"viewport scanner\",attrs:{\"id\":\"interactive\"}},[_c('video'),_vm._v(\" \"),_c('canvas',{staticClass:\"drawingBuffer\"})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-047f45f1\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/Scanner.vue\n// module id = 25\n// module chunks = 0"],"sourceRoot":""}